<html xmlns:fn="http://www.w3.org/2005/xpath-functions">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Fireworks Bare-metal Armv7-A SMP Example for GCC for bare-metal targets and Cortex-A9x4 FVP model (or Cortex-A9x1 FVP model)</title>
<style type="text/css">
    body { font-size: 62.5%;    /* default 1.0em = 16px, so 62.5% of 16 = 10. Therefore, 1.0em now = 10px, 1.2em now = 12px etc. */
        font-family: Verdana, Arial, "Lucida Grande", sans-serif; margin: 10px; padding: 0; background: #fff; min-width: 999px; }
    /* Content Styling */
    .para { font-size: 1.2em; margin-bottom: 0px; margin-top: 10px; }
    p { font-size: 1.2em; margin-bottom: 0px; margin-top: 10px; }
    h1 { font-size: 1.6em; color: #025066; margin-top: 0px; margin-bottom: 0px; }
    h2 { font-size: 1.4em; font-weight: bold; color: #025066; margin-bottom: 0px; }
    h3 { font-size: 1.2em; font-weight: bold; color: #025066; margin-bottom: 0px; }
    a { color: #127490; }
    a:hover { color: #014153; }
    div.indent { margin-left:10px; margin-right: 10px; margin-bottom: 0px; margin-top: 10px; }
    div.note { font-size: 1.0em; margin-left:10px; margin-right: 10px; margin-bottom: 0px; margin-top: 10px; }
    .table { margin-top: 5px; margin-bottom: 5px; padding:0px; }
    ul li { font-size: 1.0em; list-style-image: url(images/bullet_blue.png); }
    div.toc ul li { font-size: 1.0em; list-style-image: url(images/bullet_blue.png); }
    .table-cell { font-size: 75%; }
    .image { margin-top: 5px; margin-bottom: 5px; padding:0px; }
    .note { margin-bottom: 15px; background: #E0E0E0 }
    .toc { font-size: 115%; margin-left: 20px; margin-top: 10px; margin-bottom: 15px; }
    .italic { font-style: italic; }
    .bold { font-weight: bold; }
    .emphasis { font-weight: bold; font-style: italic; }
    .underline { text-decoration: underline; }
    .bold-underline { text-decoration: underline; font-weight: bold; }
    .arg { font-family: 'Lucida Sans Typewriter', 'Courier New', Courier, monospace; color:#333399; }
    .repl { font-style: italic; }
    .code { font-size: 1.2em; margin-top: 2px; margin-left: 20px; margin-bottom: 2px; color: #333399;
       font-family: 'Lucida Sans Typewriter', 'Courier New', Courier, monospace; }
    .menu { font-weight: bold; }
    .interface { font-weight: bold; }
    ul {margin-top: 2px; margin-bottom: 5px; }
    ol {list-style-type:decimal; margin-top: 2px; margin-bottom: 5px; }
    ol ol {list-style-type:lower-alpha; margin-top: 2px; margin-bottom: 5px; }
    ol ol ol {list-style-type:lower-roman; margin-top: 2px; margin-bottom: 5px; }
    </style>
</head>
<body>
    
    <a name="Fireworks_Bare-metal_Armv7-A_SMP_Example_for_GCC_for_bare-metal_targets_and_Cortex-A9x4_FVP_model_(or_Cortex-A9x1_FVP_model)"></a><h1>Fireworks Bare-metal Armv7-A SMP Example for GCC for bare-metal targets and Cortex-A9x4 FVP model (or Cortex-A9x1 FVP model) - Arm®Development Studio</h1>
    
        <div class="para">Fireworks example to demonstrate support for building and debugging Armv7-A SMP bare-metal applications with GCC for bare-metal targets and the Debugger.  The example runs on the multi-core Cortex-A9x4 FVP model.  The example can also run on the single core Cortex-A9x1 FVP model.</div>
    

    <div class="indent">
        <a name="Purpose_and_scope"></a><h2>Purpose and scope</h2>
        <div class="para">This example demonstrates the support for building and debugging Armv7-A SMP bare-metal applications with GCC for bare-metal targets and the Debugger.
        Fireworks is a full-featured bare-metal example written in C and assembler that produces a graphical simulated fireworks display and flying aeroplane banner on the screen.</div>
        <div class="para">For the single core model, the core moves the fireworks and the banner. For the multi-core model, core 0 moves the fireworks and core 1 moves the banner (cores 2 and 3 just sleep).</div>
        <div class="para">This bare-metal example is specifically targeted at Cortex-A9x1 FVP model or Cortex-A9x4 FVP model, complete with vector table, reset handler,
        interrupt handler, cache and MMU config, NEON support, interrupt controller (GIC) and timer initialization, LCD screen driver, retargeted printf() output to a UART, etc.</div>

        <div class="note"><div class="para">
<div class="bold">Note</div>This example is intended to be built with GCC for bare-metal targets.  If you wish to modify and rebuild the example, you must have GCC for bare-metal targets installed.  GCC for bare-metal targets is not supplied with Development Studio, but can be downloaded from developer.arm.com (see below).</div></div>

        <div class="para">The executable builds with a base address 0x80000000, and is intended for running on Cortex-A9x1 FVP model or Cortex-A9x4 FVP model.  The executable determines automatically whether it is running on a single core or multi-core model.</div>
        <div class="para">A pre-built executable (<span class="arg">fireworks-Cortex-A9xN-FVP.axf</span>) is provided, that can run on either the single-core or multi-core model.</div>
        <div class="para">This example does not depend on any semihosting support being provided by the Debugger.</div>
        <div class="para">Ready-made launch configurations <span class="arg">fireworks_GCC-Cortex-A9x1-FVP.launch</span>  and <span class="arg">fireworks_GCC-Cortex-A9x4-FVP.launch</span> are provided.</div>
        <div class="para">For a good debug view, the compiler's optimization level is set to -O1 in the <span class="arg">makefile</span>.
         You can change this to raise the optimization level to -O2 or -O3 for higher performance code generation, but at the cost of a worse debug view.</div>
    </div>

    
    <div class="indent">
        <a name="Installing_GCC_arm-none-eabi_as_a_toolchain_in_Development_Studio"></a><a name="about"></a><h2>Installing GCC arm-none-eabi as a toolchain in Development Studio</h2>
        <div class="para">To be able to modify and rebuild this example, download <a href="https://developer.arm.com/tools-and-software/open-source-software/developer-tools/gnu-toolchain/gnu-a/downloads" title="External link"><i>GCC 10.3.1 for AArch32 bare-metal targets (arm-none-eabi)</i></a>, and untar it onto your host machine (making a note of the installation directory).  Then add it as a toolchain in Development Studio as follows:</div>
        
        <ol>
           <li><div class="para">In Development Studio, select <span class="menu">Window<span class="para"> → </span>Preferences<span class="para"> → </span>Arm DS<span class="para"> → </span>Toolchains</span>.</div></li>
           <li><div class="para">In the <span class="interface">Toolchains</span> dialog, click <span class="interface">Add</span>.</div></li>
           <li><div class="para">In the <span class="interface">Select Toolchain Path</span> dialog, enter the path to the toolchain binaries.  This is normally the <span class="arg">/bin</span> sub-directory of the installation directory noted above.  Then click <span class="interface">Next</span>.</div></li>
           <li><div class="para">In the <span class="interface">Discovered Toolchain Information</span> dialog, check the toolchain information is correct, then click <span class="interface">Finish</span>.</div></li>
           <li><div class="para">The new toolchain appears in the <span class="interface">Toolchains</span> dialog, click <span class="interface">Apply</span>, then click <span class="interface">Restart</span>.</div></li>
        </ol>

    </div>


    <div class="indent">
        <a name="Building_the_example"></a><h2>Building the example</h2>
        <div class="para">This example can be built with GCC for bare-metal targets using the supplied Eclipse (managed builder) project, or directly on the command-line with the supplied <span class="arg">makefile</span> using the <span class="arg">make</span> utility.</div>
    </div>

    <div class="indent">
        <a name="Building_on_the_command-line"></a><h2>Building on the command-line</h2>
        <div class="para">To build the example on the command-line with the supplied <span class="arg">make</span> utility:</div>
        
        <ul>
           <li><div class="para">On Windows, open an <span class="interface">Arm DS Command Prompt</span> from the Start menu, run the <span class="arg">select_toolchain</span> utility, and select <span class="arg">GCC 10.3.1 [arm-none-eabi]</span> from the list</div></li>
           <li><div class="para">On Linux, run the <span class="arg">suite_exec</span> utility with the <span class="arg">--toolchain</span> option to select the compiler and start a shell configured for the Development Studio environment, for example: <span class="arg">~/developmentstudio/bin/suite_exec --toolchain "GCC 10.3.1 [arm-none-eabi]" bash</span>
</div></li>
        </ul>

        <div class="para">Then navigate to the <span class="arg">...\fireworks_A9-FVP_GCC</span> directory, and type:</div>
        <div class="para"><span class="arg">make</span></div>
        <div class="para">The usual <span class="arg">make</span> rules: <span class="arg">clean</span>, <span class="arg">all</span> and <span class="arg">rebuild</span> are provided in the <span class="arg">makefile</span>.</div>
        <div class="para">The makefile compiles the sources as:</div>
        <div class="para"><span class="arg">arm-none-eabi-gcc -c -mcpu=cortex-a9 -mfloat-abi=hard -mfpu=vfpv3-d16 -g -mthumb -O1 -DSTANDALONE</span></div>
        <div class="para">
<span class="arg">-DSTANDALONE</span> is used to select retargeting (see below).</div>
    </div>

    
    <div class="indent">
        <a name="Building_within_the_IDE"></a><h2>Building within the IDE</h2>
        <div class="para">To build the supplied projects within the IDE:</div>
        
    <ol>
        <li><div class="para">In the Project Explorer view, select the project you want to build.</div></li>
        <li><div class="para">Select <span class="menu">Project<span class="para"> → </span>Build Project</span>.</div></li>
    </ol>

    </div>


    <div class="indent">
        <a name="Running_the_example"></a><h2>Running the example</h2>
        <ol>
            <li><div class="para">Select <span class="menu">Run<span class="para"> → </span>Debug Configurations...</span>.</div></li>
            <li><div class="para">Select the <span class="arg">fireworks_GCC-Cortex-A9x4-FVP</span> or <span class="arg">fireworks_GCC-Cortex-A9x1-FVP</span> from the list of <span class="interface">Generic Arm C/C++ Application</span> configurations.</div></li>
            <li><div class="para">Click on <span class="interface">Debug</span> to start debugging.  The executable (<span class="arg">fireworks_GCC-Cortex-A9xN-FVP.axf</span>) will be downloaded to the target and it will run to the <span class="arg">main()</span> function.</div></li>

            <li><div class="para">Run the executable (press F8).  A simulated fireworks display will be displayed on the model's LCD screen.</div></li>
        </ol>
        <div class="para">You can also run the example executable directly on the FVP model from within the <span class="interface">Arm DS Command Prompt</span> on Windows or the <span class="arg">suite_exec</span> shell on Linux with, for example:</div>
<pre class="code">
FVP_VE_Cortex-A9x4 -a fireworks-Cortex-A9xN-FVP.axf -C cluster.cpu0.semihosting-stack_base=0
</pre>

        <div class="para">To use the Debugger's <span class="interface">Screen</span> view, open the view with
        <span class="menu">Window<span class="para"> → </span>Show View<span class="para"> → </span>Screen</span>, then configure it as:</div>
<pre class="code">Base Address = 0x80600000
Screen Width = 800
Screen Height = 600
Scan Line Alignment = 1
Pixel Type = BGR_16_565
Pixel Byte Order = Little Endian
</pre>
        <div class="para">The Screen view will refresh when code execution is stopped.  Higher screen resolutions take longer to refresh the Screen view.</div>
    </div>

    <div class="indent">
        <a name="Example_code_structure"></a><h2>Example code structure</h2>

        <h3>Source Files in ...\src directory</h3>
        <ul>
           <li><div class="para">
<span class="arg">startup.S</span> : assembler boot code for vector table, reset handler, interrupt handler, cache and MMU config, NEON enable, SMP.</div></li>
           <li><div class="para">
<span class="arg">MP_GIC.S</span> : assembler code for Interrupt Controller functions.</div></li>
           <li><div class="para">
<span class="arg">MP_Mutexes.S</span> : assembler code for Mutex functions.</div></li>
           <li><div class="para">
<span class="arg">MP_SCU.S</span> : assembler code for SMP functions.</div></li>
           <li><div class="para">
<span class="arg">v7.s</span> : assembler code for Cache and Branch Prediction Maintenance Operations.</div></li>
           <li><div class="para">
<span class="arg">main.c</span> : main() code that determines which cores perform which application functions</div></li>
           <li><div class="para">
<span class="arg">Fireworks.c</span> : the main fireworks application</div></li>
           <li><div class="para">
<span class="arg">timer_interrupts.c</span> : timer and interrupts initialization and handling</div></li>
           <li><div class="para">
<span class="arg">screen.c</span> : a driver for FVP LCD screen</div></li>
           <li><div class="para">
<span class="arg">retarget.c</span> : functions retarget all semihosting usage, including redirecting printf() output to the UART</div></li>
           <li><div class="para">
<span class="arg">uart.c</span> : a simple polled UART driver</div></li>
           <li><div class="para">
<span class="arg">banner_data.c</span> : Aeroplane banner (120x600) pixel array</div></li>
        </ul>

        <div class="para">Shared data and code is located in the bottom MB of memory.  This memory is configured as <span class="arg">Coherent</span> in the page tables.</div>

        <h3>Retargeting</h3>
        <div class="para">All use of semihosting to set the top of stack, base of heap, output <span class="arg">printf()</span> strings and so on, has been retargeted by way of the linker-script and <span class="arg">retarget.c</span>.
  No semihosting support is required by the executable, so semihosting does not need to be enabled in the Debugger.</div>

<h3>Boot</h3>
        <div class="para">The boot sequence for the example is shown below:</div>
<pre class="code">  Reset Vector
       |
  Reset_Handler()
       |
       ----------------------
       |                    |
  primaryCPUInit()   secondaryCPUsInit()
       |                    |
    _start()            holding_pen
       |                    :
     main()                 :
       |                    :
   SendSGI()                |
       |                    |
       ----- main_app() -----
       |                    |
  fireworks(cpu0)     fireworks(cpu1)
       |                    |
  moveSpark()          moveBanner()
</pre>
        <div class="para">The first stage of boot is the reset handler, which is common to all CPUs.  In this stage the stack pointers, MMU, page tables and caches are initialized.</div>
        <div class="para">For the second stage of boot CPU0 is treated as the primary CPU, and CPU1 is treated as secondary CPU.</div>
        <div class="para">The secondary CPU (CPU1) branches to <span class="arg">secondaryCPUsInit()</span>.  This function carries out only CPU specific (local) initialization.
        For the example this involves enabling the Processor Interface of the Interrupt Controller, and enabling the receipt of Software Generated Interrupts (SGIs).
        Once the initialization is complete the secondary CPU enters a holding pen.  It is released from the holding pen by a SGI from the primary CPU.</div>
        <div class="para">CPU0 is the primary CPU and branches to <span class="arg">primaryCPUInit()</span>.  This function performs some local initialization, but also the cluster wide (global) configuration.
        This includes configuring the SCU, and the global enable for the Interrupt Controller.  On reaching main() the primary CPU also initializes the global data used by the application.
        Once this is done it releases the secondary CPUs from the holding pen by sending a SGI.</div>

        <h3>Description of the Code Execution</h3>
        <div class="para">The main fireworks application is launched from <span class="arg">main()</span>.  <span class="arg">main()</span> is only executed by CPU0.
        <span class="arg">main()</span> performs global system operations that must be done just once.
        For example, it clears the screen, initializes the timer, wakes-up the secondary CPU, and enables the IRQ input to CPU0.
        Finally, <span class="arg">main()</span> starts an application thread <span class="arg">main_app()</span>.</div>
        <div class="para">When CPU1 wakes-up, it also calls <span class="arg">main_app()</span>, so the <span class="arg">main_app()</span> gets executed by both CPU0 and CPU1.
        <span class="arg">main_app()</span> performs per-core operations such as enabling caches and branch prediction, then calls <span class="arg">fireworks()</span>.</div>
        <div class="para">CPU0 runs the main fireworks application that fires "sparks" as fast as it can.  CPU1 displays and scrolls the banner.
        During the fireworks display, CPU0's private timer is also ticking, generating interrupts.  On each interrupt, the LEDs are advanced one position.</div>
    </div>

     <div class="indent">
        <a name="Debugging_the_example"></a><h2>Debugging the example</h2>
        <div class="para">The Debugger offers a range of powerful features for bare-metal debug, including run, stop, single-step, view/modify registers,
  view/modify variables, view/modify memory, set breakpoints, view the call stack, etc, as illustrated in the following example sessions:</div>

        <ul>
            <li><div class="para">Debugging the application</div></li>
            <li><div class="para">Debugging the reset handler</div></li>
            <li><div class="para">Viewing the MMU and page-table configuration</div></li>
            <li><div class="para">Debugging the interrupt handler</div></li>
        </ul>
    </div>

    <div class="indent">
        <a name="Debugging_the_application"></a><h2>Debugging the application</h2>
        <div class="para">To debug the application, load the executable (<span class="arg">fireworks_GCC-Cortex-A9xN-FVP.axf</span>) to the Cortex-A9x4 FVP model with <span class="menu">Run<span class="para"> → </span>Debug Configurations...</span>.</div>
        <div class="para">The Debugger will download the program's code and data sections to the target, and run to <span class="arg">main()</span> inside <span class="arg">main.c</span>.</div>
        <div class="para">Check that the 'right arrow' button at the top right of the <span class="interface">Debug Control</span> view has the <span class="arg">s</span> highlighted and the <span class="arg">i</span> greyed out, so that you are in 'source level step' mode.</div>
        <div class="para">After connecting to the target you can view each core, set (possibly conditional) breakpoints for some or all cores, examine variables, registers and memory as they appear for each core, view the call stack for each core, etc, as illustrated in the following example session:</div>

        <ol>
            <li>
            <div class="para">At <span class="arg">main()</span>, the <span class="interface">Debug Control</span> view shows all cores on the target system. Core 0 is stopped at main(), and the other cores are stopped too.</div>
            </li>
            <li>
            <div class="para">Select Core 1 in the <span class="interface">Debug Control</span> view to see that it is in a holding pen waiting to be activated by an interrupt.</div>
            </li>
            <li>
            <div class="para">Select Core 0 in the <span class="interface">Debug Control</span> view.
            Core 0 performs hardware initialization.  Step over (press F6) through the instructions and see how screen gets initialized and cleared, the timer gets initialized, and how Core 0 releases the secondary CPUs from the holding pen by sending a SGI.</div>
            </li>
            <li>
            <div class="para">Set a breakpoint on <span class="arg">if (id == 1)</span> on line 54 of <span class="arg">main.c</span>. Run to the breakpoint and see that the value of <span class="arg">id</span> as shown in the <span class="interface">Variables</span> view matches the core number shown for the highlighted core in the <span class="interface">Debug Control</span> view.</div>
            </li>
            <li>
            <div class="para">Step into <span class="arg">fireworks()</span> (press F5) and then into the <span class="arg">initSparks()</span> function.
            Inside <span class="arg">initSparks()</span> is a call to the <span class="arg">malloc()</span> library function, that returns a pointer in <span class="arg">sparks</span>.</div>
            </li>
            <li>
            <div class="para">To see Global or File Static variables, you must first add them to the view.  In the <span class="interface">Variables</span> view (bottom right), click <span class="interface">Add</span>.  In the <span class="interface">Add Variable</span> dialog, select all (press Ctrl-A), then click <span class="interface">OK</span>.</div>
            </li>
            <li>
            <div class="para">In the <span class="interface">Variables</span> view, expand <span class="interface">File Statics</span>.  Notice that <span class="arg">sparks</span> is initially a NULL pointer containing 0x0.</div>
            </li>
            <li>
            <div class="para">Step over <span class="arg">malloc()</span> (press F6 twice), and notice <span class="arg">sparks</span> change to being a valid pointer on the heap in RAM, e.g. to 0x80025360.
      This heap memory will be used to record the state of each spark (point of light) on the display.
        Expand <span class="arg">sparks</span> to view the <span class="arg">Spark</span> structure for the first instance.</div>
            </li>
            <li>
            <div class="para">Step out of <span class="arg">initSparks()</span> (press F7) and then step into <span class="arg">drawSparks()</span> and then into <span class="arg">newShell()</span>.
            Step through <span class="arg">newShell()</span> and watch the initial values of the first spark's state (x, y, xs, ys, age, type, color, data1)
            being written into the <span class="arg">sparks</span> structure in the <span class="interface">Variables</span> view.</div>
            </li>
            <li>
            <div class="para">Set a breakpoint on the <span class="arg">plot()</span> function and run to it (press F8).  Single-step through it instruction-by-instruction
        (rather than by source line) to see the <span class="arg">x</span> and <span class="arg">y</span> variables being processed in registers in the <span class="interface">Registers</span> view
        by the instruction sequence in the <span class="interface">Disassembly</span> view.</div>
            </li>
            <li>
            <div class="para">Delete all breakpoints, then set a breakpoint on line 476 of Fireworks.c: <span class="arg">if ((getNumCPUs() == 1) || (id == 1))</span>. 
            Run to the breakpoint and see that the value of <span class="arg">id</span> as shown in the <span class="interface">Variables</span> view 
            matches the core number shown for the highlighted core in the <span class="interface">Debug Control</span> view.  Do this a few times.</div>
            </li>
            <li>
            <div class="para">Delete all breakpoints.</div>
            </li>
            <li>
            <div class="para">The next 4 lines of code ensure that <span class="arg">moveBanner()</span> is called if there is only one CPU, or for CPU 1 only in multi-core systems, and then only if the model's USERSW1 switch is off.
            To see this in action, set a breakpoint on <span class="arg">moveBanner()</span>, then continue execution.  Switch USERSW1 on to stop the banner moving.  Switch USERSW1 off to restart the banner.</div>
            </li>
            <li>
            <div class="para">Delete all breakpoints, then disconnect.</div>
            </li>
        </ol>
    </div>

    <div class="indent">
        <a name="Debugging_the_reset_handler"></a><h2>Debugging the reset handler</h2>
        <div class="para">To debug the reset handler, load the executable in the same way as before, but this time select "Debug from entry point" in the <span class="interface">Debugger</span> tab.</div>
        <div class="para">The Debugger will download the program's code and data sections to the target, and set the program counter PC to the entry point of the image,
at the reset entry in the vector table, on the <span class="arg">B Reset_Handler</span> instruction in <span class="arg">startup.S</span> at address 0x80000000.</div>

        <ol>
            <li>
            <div class="para">In the <span class="interface">Debug Control</span> view, choose <span class="interface">Cortex-A9_0</span> to debug the CPU0 code.</div>
            </li>
            <li>
            <div class="para">In the <span class="interface">Registers</span> view, expand <span class="interface">Core</span> to see the core registers.</div>
            </li>
            <li>
            <div class="para">Execute the <span class="arg">B Reset_Handler</span> instruction by single-stepping (press F5) into <span class="arg">Reset_Handler</span>.  Notice the Program Counter (PC) change in the <span class="interface">Core</span> registers view.</div>
            </li>
            <li>
            <div class="para">The first instructions inside <span class="arg">Reset_Handler</span> (MRC, BIC, MCR) perform a read/modify/write of CP15 Control Register to disable the caches, MMU and branch prediction.
      In the <span class="interface">Registers</span> view, expand <span class="interface">CP15</span>, then expand <span class="interface">System</span>, then expand <span class="interface">SCTLR</span>.
      Single-step (press F5) through these instructions, and see the I, C, M and Z bits being cleared (if they were previously set).</div>
            </li>
            <li>
            <div class="para">The next block of instructions initializes IRQ and SYS mode stacks. Expand <span class="interface">Core</span> and then expand <span class="interface">IRQ</span> in <span class="interface">Registers</span> view.
            Single-step (press F5) through these instructions and see <span class="interface">SP_IRQ</span> and <span class="interface">SP</span> being initialized. </div>
            </li>
            <li>
            <div class="para">The next instructions set the Vector Base Address Register (VBAR) to point to this application's vector table.
            In the <span class="interface">Registers</span> view, inside the expanded <span class="interface">CP15</span>, <span class="interface">System</span>.
            Single-step (press F5) through these instructions, and see the <span class="interface">VBAR</span> being set to 0x80000000.</div>
            </li>
            <li>
            <div class="para">Step-over (press F6) <span class="arg">disableHighVecs</span>.</div>
            </li>
            <li>
            <div class="para">Step-over (press F6) <span class="arg">invalidateCaches()</span> that invalidates the caches.</div>
            </li>
            <li>
            <div class="para">The next instructions invalidate the branch predictor and TLBs, then setup the domains, the location of the level 1 page table, and activate VFP/NEON if required.  Single-step (press F5) through these instructions and watch their effects on the CP15 registers.</div>
            </li>
            <li>
            <div class="para">So far, all reset handler code has been executed by all CPUs.  The next instructions fork the code depending on the CPU.  For CPU0, primary CPU initialization is performed.  For the other CPUs, secondary CPU initialization is performed.  Set breakpoints on <span class="arg">primaryCPUInit</span> and <span class="arg">secondaryCPUsInit</span>, and continue execution (press F8).</div>
            </li>
            <li>
            <div class="para">Step through <span class="arg">primaryCPUInit</span> to see CPU0 generate page-tables (the page-table configuration will be studied in the next section), enable the Memory Management Unit (MMU) (the caches are left disabled until after scatter-loading), enable the Snoop Control Unit (SCU), join SMP and initialize the Generic Interrupt Controller (GIC), before branching to the C library run-time initialization code <span class="arg">_start</span>.</div>
            </li>
            <li>
            <div class="para">Run to <span class="arg">secondaryCPUsInit</span> to see the other CPUs initialize the Generic Interrupt Controller (GIC), join SMP, then enter a holding pen.</div>
            </li>
            <li>
            <div class="para">Delete all breakpoints, then disconnect.</div>
            </li>
        </ol>
    </div>

    <div class="indent">
        <a name="Viewing_the_MMU_and_page-table_configuration"></a><h2>Viewing the MMU and page-table configuration</h2>
        <div class="para">Load the executable in the same way as before, but this time select "Debug from symbol" <span class="arg">main</span> in the <span class="interface">Debugger</span> tab.</div>
        <div class="para">The Debugger will download the program's code and data sections to the target, and run to <span class="arg">main()</span> inside <span class="arg">main.c</span>.  Startup code executed earlier by CPU0 will have already configured the page-tables and enabled the MMU.  To view the MMU and page-table configuration:</div>
        <ol>
            <li>
            <div class="para">Open the <span class="interface">MMU/MPU</span> view with <span class="menu">Window<span class="para"> → </span>Show View<span class="para"> → </span>MMU/MPU</span>.</div>
            </li>
            <li>
            <div class="para">In the <span class="interface">MMU/MPU</span> view, select the <span class="interface">Memory Map</span> tab.  This gives a top-level view of the virtual memory layout, by combining translation table entries that map to contiguous regions of physical memory with common memory type, cacheability, shareability and access attributes.</div>
            </li>
            <li>
            <div class="para">In the <span class="interface">MMU/MPU</span> view, select the <span class="interface">Tables</span> tab, then expand <span class="interface">TTBR0</span>.  The lower pane shows TTBR0 points to page-tables at SP:0x80500000.  Scroll down through the page-tables to see (non Fault) entries at 0x1C000000, 0x1C100000, 0x2C000000, 0x80000000, 0x80600000.  Notice that for this example, each entry is "flat-mapped" - an input (virtual) address 0x80000000 maps to the same output (physical) address 0x80000000.</div>
            </li>
            <li>
            <div class="para">In the <span class="interface">Commands</span> view, enter <span class="arg">mmu print</span>.  This gives a similar output to the above:</div>
<pre class="code">
mmu print
Input Address | Type          | Next Level    | Output Address | Properties
----------------------------------------------------------------------------------------------------------------------------------
+ 0x00000000  | TTBR0         | SP:0x80500000 |                | EAE=0, PD1=0, PD0=0, N=0, IRGN=0x0, NOS=0, RGN=0x0, S=0
 - 0x00000000 | Fault (x448)  |               |                |
 - 0x1C000000 | Section       |               | SP:0x1C000000  | NS=0, nG=0, S=0, AP=0x3, TEX=0x0, Domain=0, XN=1, C=0, B=1, PXN=0
 - 0x1C100000 | Section       |               | SP:0x1C100000  | NS=0, nG=0, S=0, AP=0x3, TEX=0x0, Domain=0, XN=1, C=0, B=1, PXN=0
 - 0x1C200000 | Fault (x254)  |               |                |
 - 0x2C000000 | Section       |               | SP:0x2C000000  | NS=0, nG=0, S=0, AP=0x3, TEX=0x0, Domain=0, XN=1, C=0, B=1, PXN=0
 - 0x2C100000 | Fault (x1343) |               |                |
 - 0x80000000 | Section       |               | SP:0x80000000  | NS=0, nG=0, S=1, AP=0x3, TEX=0x4, Domain=0, XN=0, C=0, B=1, PXN=0
 - 0x80100000 | Fault (x5)    |               |                |
 - 0x80600000 | Section       |               | SP:0x80600000  | NS=0, nG=0, S=0, AP=0x3, TEX=0x0, Domain=0, XN=1, C=0, B=1, PXN=0
 - 0x80700000 | Fault (x2041) |               |                |
:
</pre>
            </li>
            <li>
            <div class="para">In the <span class="interface">MMU/MPU</span> view, select the <span class="interface">Translation</span> tab.  This allows you to see which physical address is mapped to a particular virtual address, and vice-versa.  For example, enter 0x80000000, select <span class="interface">Virtual to Physical</span> then press <span class="interface">Translate</span>.  The lower pane shows the translated address.  For this example, the translated address is 0x80000000 because this example uses "flat-mapping".  Now select <span class="interface">Physical to Virtual</span> then press <span class="interface">Translate</span>.  Again the result is 0x80000000.</div>
            </li>
            <li>
            <div class="para">In the <span class="interface">Commands</span> view, enter <span class="arg">mmu translate 0x80000000</span> then press <span class="interface">Submit</span>.  This gives a similar output to the Virtual to Physical address translation above.  To translate Physical to Virtual addresses, enter, for example, <span class="arg">mmu translate SP:0x80000000</span>.</div>
            </li>
            <li>
            <div class="para">Disconnect.</div>
            </li>
        </ol>
    </div>

    <div class="indent">
        <a name="Debugging_the_interrupt_handler"></a><h2>Debugging the interrupt handler</h2>
        <div class="para">To debug the interrupt handler, load the executable in the same way as before, but this time select "Debug from symbol" <span class="arg">main</span> in the <span class="interface">Debugger</span> tab.</div>
        <div class="para">The Debugger will download the program's code and data sections to the target, and run to <span class="arg">main()</span> inside <span class="arg">main.c</span>.</div>

        <ol>
            <li>
            <div class="para">Set a breakpoint on the <span class="arg">fireworks(id)</span> function and run to it (press F8).</div>
            </li>
            <li>
            <div class="para">Select Core 0 in the <span class="interface">Debug Control</span> view.</div>
            </li>
            <li>
            <div class="para">In the <span class="interface">Breakpoints</span> view, click on the <span class="interface">Manage Signals...</span> button, select <span class="interface">Stop</span> and <span class="interface">Print</span> for <span class="interface">IRQ</span>, then <span class="interface">OK</span>.  This is equivalent to typing <span class="arg">handle IRQ stop</span> on the CLI.</div>
            </li>
            <li>
            <div class="para">Continue execution by pressing the green run/continue button (press F8).  The fireworks display will start, and the IRQ breakpoint will be hit shortly after, due to the timer interrupt occurring.</div>
            </li>
            <li>
            <div class="para">Restart execution again (press F8).  The LEDs will advance, and the fireworks display run for another short period until the timer interrupt occurs again.</div>
            </li>
            <li>
            <div class="para">Single-step (press F5) through the <span class="arg">IRQ_Handler</span> and observe the APCS-corruptible registers being pushed onto the stack,
            and step again to see C code being called from assembler, continue stepping until <span class="arg">C_interrupt_handler()</span>.</div>
            </li>
            <li>
            <div class="para">
<span class="arg">C_interrupt_handler()</span> clears the timer interrupt and advances the LED sequence.
            Step through this C code in <span class="arg">C_interrupt_handler()</span>, and back out
            through the assembler code of <span class="arg">IRQ_Handler</span> that pops the APCS-corruptible registers off the stack,
            and finally returns from the interrupt.</div>
            </li>
            <li>
            <div class="para">Delete all breakpoints, and continue running (press F8).</div>
            </li>
        </ol>
    </div>
    
    <div class="indent">
        <a name="Known_issues_and_troubleshooting"></a><h2>Known issues and troubleshooting</h2>
        <ul>
            
    <li>
<div class="para">On Windows 7 and later, launching a debug configuration to connect to a Fixed Virtual Platform (FVP) model may give the following error: <span class="arg">Windows cannot find "C:\Windows\System32\telnet.exe"</span> or <span class="arg">No telnet executable was found on your system</span>.  Arm FVP models make use of "telnet" as a serial terminal, to enable serial data to be transferred from application code running on an Arm FVP via a modelled UART to a serial terminal.  This error occurs when the telnet client is disabled or otherwise unavailable on your computer.  The telnet client is not enabled by default on Windows 7 and later.  To enable the telnet client on Windows 10:</div>
        <ol>
            <li><div class="para">Right-click on the Start menu, then select "Settings"</div></li>
            <li><div class="para">Search for "Telnet", and select "Turn Windows features on or off"</div></li>
            <li><div class="para">From the list that appears, tick the "Telnet Client" checkbox</div></li>
            <li><div class="para">Click "OK" to close the dialog.</div></li>
        </ol>
    </li>

        </ul>
    </div>

    <h2>See also:</h2>
<div class="indent"><ul>
        <li><div class="para"><a href="https://developer.arm.com/documentation/101469/latest/Debugging-code/Overview--Debug-connections-in-Arm-Debugger"><i>Debug connections in Arm Debugger</i> in <i>Arm Development Studio Getting Started Guide</i></a></div></li>
        <li><div class="para"><a href="https://developer.arm.com/documentation/101470/latest/"><i>Arm Development Studio User Guide</i></a></div></li>
        <li><div class="para"><a href="https://developer.arm.com/documentation/101471/latest/"><i>Arm Debugger Command Reference</i></a></div></li>
        <li><div class="para"><a href="https://developer.arm.com/documentation/100966/latest/"><i>Fixed Virtual Platforms FVP Reference Guide</i></a></div></li>
    </ul></div>
<br><br><div align="left" class="legal">
<hr>Copyright© 2010-2022 Arm Limited (or its affiliates). All rights reserved.</div>
</body>
</html>
